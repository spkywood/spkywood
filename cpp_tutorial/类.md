# C++ 类 `class`

## `class` 和 `struct` 的区别

- `class` 引用类型，它在堆中分配空间，栈中保存的只是引用

- `struct` 是值类型，它在栈中分配空间

- 默认访问权限 `struct` 是数据结构的实现体，默认的数据访问控制是 `public`, `class` 是对象的实现体，默认的成员变量访问控制是private的。

- 默认的继承访问权。 `class` 默认的是 `private` , `strcut` 默认的是 `public`。

- `class` 这个关键字还用于定义模板参数，就像 `typename` 。但关建字 `struct` 不用于定义模板参数

---

### `c` 中的 `struct`

- `struct` 是一种数据类型，不能定义函数，所以在面向c的过程中，struct不能包含任何函数。

### `C++` 中的 `struct`

1. `struct` 可以包括成员函数

2. `struct` 可以实现继承

3. `struct` 可以实现多态

---

## `C++ class`

类的基本思想是**数据抽象** 和 **封装**

- 类作用域

- 数据成员

- 构造函数
    
    - 默认构造函数
    - 拷贝构造函数
    - 赋值构造函数
    - 委托构造函数

- 成员函数

    - 成员函数
    - 非成员函数
    - 友元函数

- 隐式 `this` 指针

- 内联函数

- `const`

- `static`

- `mutable`

---

### 拷贝控制

- **拷贝构造函数**

构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值。

```C++
class Foo {
public:
    Foo();              // 默认构造函数
    Foo(const Foo&);    // 拷贝构造函数
    
    // ...
};
```

1. 拷贝构造函数通常不应该是 `explicit`

2. 如果没有定义拷贝构造函数，编译器会自定义一个

3. 拷贝初始化

```C++
// 直接初始化
std::string dots(10, '.');          
std::string s(dots);

// 拷贝初始化
std::string s2 = dots;
std::string null_book = "9-999-9999-9";
std::string nines = std::string(100, '9');
```

- **拷贝赋值运算符**

- **移动构造函数**

- **移动赋值运算符**

- **析构函数**

---

### 运算符重载

<br>

- C++中**运行时的多态性主要通过虚函数**来实现，而**编译时的多态性由函数重载和运算符重载**来实现。

- 重载运算符与预定义运算符的使用方法完全相同，被重载的运算符不改变原来的操作数个数、优先级和结合性。

- 重载的运算符只能是运算符集中的运算符，不能另创新的运算符。

- 在 C++中，不能被重载的运算符，类属关系运算符`.`、成员指针运算符 `.*` 及 `->*`、作用域标识符`::`、`sizeof`运算符和三目运算符`?:`。

- 运算符的含义可以改变，但最好不要改变。如实数的加法运算可以用乘法运算符来实现。

- 不能改变运算符对预定义类型的操作方式，即至少要有一个操作对象是自定义类型，这样做的目的是为了防止用户修改用于基本类型数据的运算符性质。

- 运算符重载函数不能包括缺省的参数。

- 除赋值运算符重载函数外，其他运算符重载函数都可以由派生类继承。

- 二元运算符中，第一个操作数为非对象时，必须使用友元函数。如输入输出运算符 `<<` 和 `>>` 。

- 用于类对象的运算符一般必须重载，但有两个例外，赋值运算符 `=` 和 地址运算符 `&` 不必用户重载。

- 运算符的重载只能显式重载，不能隐式重载。例如重载了 `+`，要想执行 `+=` 运算，必须再对其进行显式的重载。

<br>

**运算符重载原则表**

运算符 | 建议使用方式 
---------|----------
 一元运算符 | 成员函数
 `＝ () [] ->` | **必须是成员函数**
 `+= -= /= *= ^= &= != %= >>= <<=` | **必须是成员函数**
 所有其它二元运算符, 例如: `+, -, *, /` | 友元函数
 `<<` `>>` | 友元函数

---

### 继承

---

## `C++` 对象内存分配

- `c++` 类成员变量的内存分布是 **从上到下** ，按照内存对齐的原则进行分布的。

#### 内存对齐原则：

- 分配内存的顺序是按照声明的顺序。

- 每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止。

- 最后整个类的大小必须是里面变量类型最大值的整数倍。

```C++
#include <iostream>

class A{
	char a;     // char 一个字节 (后面+3字节)
	int b;      // int  四个字节 (qi)
	char c;     // char 一个字节
};

class B{
	char a;
	char c;
	int b;
};


int main(){
	std::cout << sizeof(A) << std::endl;    // cout 12
	std::cout << sizeof(B) << std::endl;	// cout 8
} 
```

- 除了类，联合和结构体也是这样的对齐规则。

- 平台原因(移植原因)：某些硬件平台只能在某些地址处取某些特定类型的数据，不能访问任意地址。

- 性能原因：访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问

- 对象所占的空间大小只取决于该对象中数据成员所占的空间，而与成员函数无关。

[c++类对象的内存分布](https://zoux86.github.io/post/2019-12-04-c++%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/)