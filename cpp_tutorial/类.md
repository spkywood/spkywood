# C++ 类 `class`

## `class` 和 `struct` 的区别

- `class` 引用类型，它在堆中分配空间，栈中保存的只是引用

- `struct` 是值类型，它在栈中分配空间

- 默认访问权限 `struct` 是数据结构的实现体，默认的数据访问控制是 `public`, `class` 是对象的实现体，默认的成员变量访问控制是private的。

- 默认的继承访问权。 `class` 默认的是 `private` , `strcut` 默认的是 `public`。

- `class` 这个关键字还用于定义模板参数，就像 `typename` 。但关建字 `struct` 不用于定义模板参数

---

### `c` 中的 `struct`

- `struct` 是一种数据类型，不能定义函数，所以在面向c的过程中，struct不能包含任何函数。

### `C++` 中的 `struct`

1. struct可以包括成员函数

2. struct可以实现继承

3. struct可以实现多态

---

## `C++ class`

类的基本思想是**数据抽象** 和 **封装**

- 类作用域

- 数据成员

- 构造函数

- 成员函数

- 隐式 `this` 指针

- 友元

- `const`

- `static`

- `mutable`

---

### 拷贝控制

- **拷贝构造函数**

构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值。

```C++
class Foo {
public:
    Foo();              // 默认构造函数
    Foo(const Foo&);    // 拷贝构造函数
    
    // ...
};
```

1. 拷贝构造函数通常不应该是 `explicit`

2. 如果没有定义拷贝构造函数，编译器会自定义一个

3. 拷贝初始化

```C++
// 直接初始化
std::string dots(10, '.');          
std::string s(dots);

// 拷贝初始化
std::string s2 = dots;
std::string null_book = "9-999-9999-9";
std::string nines = std::string(100, '9');
```

- **拷贝赋值运算符**

- **移动构造函数**

- **移动赋值运算符**

- **析构函数**

---

### 运算符重载

---
### 继承

---

## `C++` 对象内存分配

- `c++` 类成员变量的内存分布是 **从上到下** ，按照内存对齐的原则进行分布的。

#### 内存对齐原则：

- 分配内存的顺序是按照声明的顺序。

- 每个变量相对于起始位置的偏移量必须是该变量类型大小的整数倍，不是整数倍空出内存，直到偏移量是整数倍为止。

- 最后整个类的大小必须是里面变量类型最大值的整数倍。

```C++
#include <iostream>

class A{
	char a;     // char 一个字节 (后面+3字节)
	int b;      // int  四个字节 (qi)
	char c;     // char 一个字节
};

class B{
	char a;
	char c;
	int b;
};


int main(){
	std::cout << sizeof(A) << std::endl;    // cout 12
	std::cout << sizeof(B) << std::endl;	// cout 8
} 
```

- 除了类，联合和结构体也是这样的对齐规则。

- 平台原因(移植原因)：某些硬件平台只能在某些地址处取某些特定类型的数据，不能访问任意地址。

- 性能原因：访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问

- 对象所占的空间大小只取决于该对象中数据成员所占的空间，而与成员函数无关。

[c++类对象的内存分布](https://zoux86.github.io/post/2019-12-04-c++%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83/)